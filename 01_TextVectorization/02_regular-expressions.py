# Регулярные выражения

# От лишних символов текст очистят регулярные выражения (англ. regular expressions).
# Это инструмент для поиска слова или числа по шаблону (англ. pattern). Он определяет,
# из каких частей состоит строка и какие в них символы. Например, нужно найти все
# даты в таком формате записи: 02.02.2020. Их шаблон — это два числа, точка,
# два числа, точка, четыре числа.

# Шаблон для email-адреса такой: строка на латинице, символ @, строка
# на латинице, точка, строка на латинице.
# Для работы с регулярными выражениями в Python есть встроенный
# модуль re (сокр. от regular expressions):

import re

# Познакомимся с функцией re.sub() (от англ. substitute, «заменять»).
# Она находит в тексте все совпадения по шаблону и заменяет их
# заданной строкой.

# pattern — шаблон
# replacement — на что заменять
# text — текст, в котором искать совпадения
re.sub(pattern, replacement, text)

# Вернёмся к нашей задаче. В лемматизированном тексте твита нужно
# оставить только кириллические символы и пробелы. Чтобы их найти,
# напишем регулярное выражение.
# Оно начинается с символа r, заключается в кавычки и квадратные
# скобки:

r'[]'

# В квадратных скобках перечисляют все символы, подходящие под
# шаблон (в любом порядке, без пробелов). Запишем, что ищем буквы
# от «а» до «я». Они могут быть как в нижнем, так и верхнем
# регистрах, поэтому получаем:
# диапазон букв обозначается дефисом:
# а-я — это то же самое, что абвгдежзийклмнопрстуфхцчшщъыьэюя
r'[а-яА-Я]'

r'[а-яА-ЯёЁ]'

# Возьмём исходный текст твита. Под наш шаблон подходят
# кириллические символы и пробелы, которые как раз нужно оставить.
# Но если мы вызовем функцию re.sub(), их заменят пробелы.
# Чтобы указать, что символы под шаблон не подходят, перед набором
# символов поставим знак «домика» (^):

# уже лемматизированный текст
text = "@first_timee хоть я и школота, но поверь, у мы то же самый :d общество профилировать предмет типа)"
re.sub(r'[^а-яА-ЯёЁ ]', ' ', text)

# Так в тексте остались только кириллические символы и пробелы. После этой операции в тексте можно обнаружить лишние пробелы, для анализа они — помеха. Пробелы устраняются комбинацией функций join() и split().
# Возьмём пример текста с лишними пробелами: в середине, начале и конце строки. Методом split() преобразуем его в список. Если не указывать аргументы у split(), он делает разбиение по пробелам или группам пробелов:
text = "            хоть я и школота  но поверь  "
text.split()

# Получили список без пробелов:
['хоть', 'я', 'и', 'школота', 'но', 'поверь']

# Методом join() объединим элементы в строку через пробел:
" ".join(['хоть', 'я', 'и', 'школота', 'но', 'поверь'])

# Пробелов ровно столько, сколько нужно:
'хоть я и школота но поверь'

#### EXERCISE #1 ####
# Напишите функцию clear_text(text), которая оставит в тексте
# только кириллические символы и пробелы. На вход она принимает
# текст, а возвращает очищенный текст. Дополнительно уберите
# лишние пробелы.
# Напечатайте на экране исходный текст, а затем очищенный и
# лемматизированный тексты.

# Чтобы избавиться от лишних пробелов, вызовите
# " ".join(text.split())


import pandas as pd
from pymystem3 import Mystem
# Для работы с регулярными выражениями в Python есть встроенный модуль re (сокр. от regular expressions):
import re

data = pd.read_csv('/datasets/tweets.csv')
corpus = list(data['text'])


def lemmatize(text):
    m = Mystem()
    lemm_list = m.lemmatize(text)
    lemm_text = "".join(lemm_list)

    return lemm_text


def clear_text(text):
    clr = re.sub(r'[^а-яА-ЯёЁ ]', ' ', text)
    cleared_text = " ".join(clr.split())
    return cleared_text


print("Исходный текст:", corpus[0])
print("Очищенный и лемматизированный текст:", lemmatize(clear_text(corpus[0])))

# Output
# Исходный текст: @first_timee хоть я и школота, но поверь, у нас то же самое :D общество профилирующий предмет типа)
# Очищенный и лемматизированный текст: хоть я и школоть но поверять у мы то же самый общество профилировать предмет тип